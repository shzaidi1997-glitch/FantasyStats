<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Football Analytics 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1a1333;
            --bg-secondary: #251d45;
            --bg-card: #2d2252;
            --accent-purple: #8b5cf6;
            --accent-pink: #ec4899;
            --accent-cyan: #22d3ee;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --success: #22c55e;
            --warning: #eab308;
            --danger: #ef4444;
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-card: linear-gradient(180deg, rgba(139, 92, 246, 0.1) 0%, rgba(45, 34, 82, 0.8) 100%);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            background-image: radial-gradient(ellipse at 20% 20%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(236, 72, 153, 0.1) 0%, transparent 50%);
            color: var(--text-primary);
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; margin-bottom: 20px; }
        .header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, #22d3ee 0%, #8b5cf6 50%, #ec4899 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 3px;
            margin-bottom: 10px;
        }
        .header .subtitle { font-size: 1.2rem; color: var(--text-secondary); }
        .loading { text-align: center; padding: 100px 20px; }
        .loading-spinner {
            width: 60px; height: 60px;
            border: 4px solid var(--bg-card);
            border-top-color: var(--accent-purple);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        .loading-status { color: var(--text-secondary); margin-top: 10px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .nav-tabs {
            display: flex; flex-wrap: wrap; gap: 8px;
            justify-content: center; margin-bottom: 30px; padding: 10px;
            background: rgba(45, 34, 82, 0.5); border-radius: 16px;
        }
        .nav-tab {
            padding: 12px 20px; background: transparent; border: none;
            color: var(--text-secondary); font-family: 'Inter', sans-serif;
            font-size: 0.9rem; font-weight: 500; cursor: pointer;
            border-radius: 10px; transition: all 0.3s ease;
            display: flex; align-items: center; gap: 8px;
        }
        .nav-tab:hover { background: var(--bg-card); color: var(--text-primary); }
        .nav-tab.active {
            background: var(--gradient-primary); color: white;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }
        .tab-content { display: none; animation: fadeIn 0.4s ease; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .card {
            background: var(--gradient-card);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 16px; padding: 24px; margin-bottom: 20px;
        }
        .card:hover { border-color: rgba(139, 92, 246, 0.4); box-shadow: 0 8px 32px rgba(139, 92, 246, 0.15); }
        .card-title { font-family: 'Orbitron', sans-serif; font-size: 1.4rem; font-weight: 600; color: var(--accent-cyan); margin-bottom: 8px; }
        .card-subtitle { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 20px; }
        .overview-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card {
            background: var(--gradient-card);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 16px; padding: 24px; text-align: center;
            transition: all 0.3s ease;
        }
        .stat-card:hover { transform: translateY(-4px); border-color: var(--accent-purple); }
        .stat-card .label { font-size: 0.85rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .stat-card .value { font-family: 'Orbitron', sans-serif; font-size: 1.3rem; font-weight: 700; color: var(--accent-cyan); margin-bottom: 4px; }
        .stat-card .detail { font-size: 0.9rem; color: var(--text-secondary); }
        .stat-card .highlight { color: var(--success); }
        .stat-card.champion { background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(139, 92, 246, 0.3) 100%); border-color: gold; }
        .stat-card.champion .value { color: gold; }
        .ranking-list { display: flex; flex-direction: column; gap: 12px; }
        .ranking-item {
            display: flex; align-items: center; padding: 16px 20px;
            background: rgba(45, 34, 82, 0.6); border-radius: 12px;
            border: 1px solid rgba(139, 92, 246, 0.15);
            flex-wrap: wrap; gap: 10px;
        }
        .ranking-item:hover { background: rgba(56, 42, 101, 0.8); }
        .ranking-item .rank { font-family: 'Orbitron', sans-serif; font-size: 0.9rem; font-weight: 700; color: var(--accent-purple); min-width: 40px; }
        .ranking-item .rank.gold { color: #ffd700; }
        .ranking-item .rank.silver { color: #c0c0c0; }
        .ranking-item .rank.bronze { color: #cd7f32; }
        .ranking-item .name { flex: 1; font-weight: 500; margin-left: 12px; min-width: 120px; }
        .ranking-item .stat { font-family: 'Orbitron', sans-serif; font-weight: 600; font-size: 1rem; }
        .ranking-item .stat.positive { color: var(--success); }
        .ranking-item .stat.negative { color: var(--danger); }
        .ranking-item .stat.neutral { color: var(--accent-cyan); }
        .ranking-item .sub-stat { font-size: 0.8rem; color: var(--text-secondary); margin-left: 8px; }
        .progress-container { flex: 1; margin: 0 20px; min-width: 150px; }
        .progress-bar { height: 8px; background: rgba(139, 92, 246, 0.2); border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple)); border-radius: 4px; }
        .progress-label { font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px; }
        .two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 900px) { .two-column { grid-template-columns: 1fr; } }
        .awards-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; }
        .award-card {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(236, 72, 153, 0.1) 100%);
            border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px;
            padding: 20px; text-align: center;
        }
        .award-card:hover { transform: scale(1.02); border-color: var(--accent-pink); }
        .award-card .award-title { font-size: 0.8rem; color: var(--accent-pink); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .award-card .winner { font-family: 'Orbitron', sans-serif; font-size: 1.1rem; font-weight: 600; color: var(--success); margin-bottom: 4px; }
        .award-card .detail { font-size: 0.85rem; color: var(--text-secondary); }
        .trade-item { background: rgba(45, 34, 82, 0.6); border-radius: 12px; padding: 16px; margin-bottom: 12px; border: 1px solid rgba(139, 92, 246, 0.15); }
        .trade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
        .trade-team { font-weight: 600; color: var(--text-primary); }
        .trade-value { font-family: 'Orbitron', sans-serif; font-weight: 600; }
        .trade-value.positive { color: var(--success); }
        .trade-value.negative { color: var(--danger); }
        .trade-players { display: flex; gap: 20px; font-size: 0.85rem; flex-wrap: wrap; }
        .trade-got { color: var(--success); }
        .trade-gave { color: var(--danger); }
        .trade-got span, .trade-gave span { color: var(--text-secondary); font-size: 0.75rem; }
        .waiver-item { display: flex; align-items: center; padding: 12px 16px; background: rgba(45, 34, 82, 0.6); border-radius: 10px; margin-bottom: 8px; flex-wrap: wrap; gap: 10px; }
        .waiver-rank { font-family: 'Orbitron', sans-serif; font-size: 0.85rem; font-weight: 700; color: var(--warning); min-width: 35px; }
        .waiver-player { flex: 1; margin-left: 10px; min-width: 150px; }
        .waiver-player .name { font-weight: 500; color: var(--success); }
        .waiver-player .info { font-size: 0.8rem; color: var(--text-secondary); }
        .waiver-points { font-family: 'Orbitron', sans-serif; font-weight: 600; color: var(--warning); }
        .draft-comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
        @media (max-width: 768px) { .draft-comparison { grid-template-columns: 1fr; } .header h1 { font-size: 2rem; } }
        .draft-column h3 { font-family: 'Orbitron', sans-serif; font-size: 1rem; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid; }
        .draft-column.actual h3 { color: var(--accent-cyan); border-color: var(--accent-cyan); }
        .draft-column.drafted h3 { color: var(--accent-pink); border-color: var(--accent-pink); }
        .draft-pick { display: flex; align-items: center; padding: 10px 12px; background: rgba(45, 34, 82, 0.4); border-radius: 8px; margin-bottom: 6px; font-size: 0.85rem; }
        .draft-pick .pick-num { font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--warning); min-width: 30px; }
        .draft-pick .player-name { flex: 1; margin-left: 8px; }
        .draft-pick .player-name.success { color: var(--success); }
        .draft-pick .player-name.danger { color: var(--danger); }
        .draft-pick .points { font-family: 'Orbitron', sans-serif; font-size: 0.8rem; }
        .draft-pick .points.success { color: var(--success); }
        .draft-pick .points.danger { color: var(--danger); }
        .draft-pick .drafter { font-size: 0.75rem; color: var(--text-secondary); margin-left: 8px; }
        .matchup-score { font-size: 1.1rem; margin: 10px 0; }
        .matchup-score .winner-score { color: var(--success); font-weight: 600; }
        .matchup-score .loser-score { color: var(--danger); font-weight: 600; }
        .error { text-align: center; padding: 60px 20px; color: var(--danger); }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--bg-card); border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 id="league-name">Loading...</h1>
            <p class="subtitle">2025 Season Analytics</p>
        </header>
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <p>Loading league data...</p>
            <p class="loading-status" id="loading-status">Fetching league info...</p>
        </div>
        <div id="content" style="display: none;">
            <nav class="nav-tabs">
                <button class="nav-tab active" data-tab="overview"><span class="icon">üèÜ</span> Overview</button>
                <button class="nav-tab" data-tab="efficiency"><span class="icon">üéØ</span> Efficiency</button>
                <button class="nav-tab" data-tab="schedule"><span class="icon">üìà</span> Schedule</button>
                <button class="nav-tab" data-tab="consistency"><span class="icon">‚ö°</span> Consistency</button>
                <button class="nav-tab" data-tab="trades"><span class="icon">üîÑ</span> Trades</button>
                <button class="nav-tab" data-tab="waivers"><span class="icon">‚≠ê</span> Waivers</button>
                <button class="nav-tab" data-tab="draft"><span class="icon">üìã</span> Draft</button>
                <button class="nav-tab" data-tab="playoffs"><span class="icon">üèÜ</span> Playoffs</button>
                <button class="nav-tab" data-tab="awards"><span class="icon">üéñÔ∏è</span> Awards</button>
            </nav>
            <div id="overview" class="tab-content active">
                <div class="overview-grid" id="overview-stats"></div>
                <div class="two-column">
                    <div class="card"><h2 class="card-title">Biggest Blowout</h2><div id="biggest-blowout"></div></div>
                    <div class="card"><h2 class="card-title">Closest Matchup</h2><div id="closest-matchup"></div></div>
                </div>
            </div>
            <div id="efficiency" class="tab-content">
                <div class="card">
                    <h2 class="card-title">Lineup Efficiency - All Teams</h2>
                    <p class="card-subtitle">How well you set your lineup vs optimal possible</p>
                    <div class="ranking-list" id="efficiency-list"></div>
                </div>
            </div>
            <div id="schedule" class="tab-content">
                <div class="card">
                    <h2 class="card-title">Schedule Luck</h2>
                    <p class="card-subtitle">Expected wins based on points scored vs actual record</p>
                    <div class="ranking-list" id="schedule-luck-list"></div>
                </div>
                <div class="card">
                    <h2 class="card-title">Strength of Schedule</h2>
                    <p class="card-subtitle">Average points scored against you (higher = tougher schedule)</p>
                    <div class="ranking-list" id="sos-list"></div>
                </div>
            </div>
            <div id="consistency" class="tab-content">
                <div class="card">
                    <h2 class="card-title">Consistency</h2>
                    <p class="card-subtitle">Higher = predictable, Lower = boom/bust</p>
                    <div class="ranking-list" id="consistency-list"></div>
                </div>
            </div>
            <div id="trades" class="tab-content">
                <div class="card">
                    <h2 class="card-title">Net Trade Performance</h2>
                    <p class="card-subtitle">Fantasy points gained/lost from traded players (points scored after trade)</p>
                    <div class="ranking-list" id="trade-performance-list"></div>
                </div>
                <div class="card">
                    <h2 class="card-title">All Trades</h2>
                    <div id="all-trades-list"></div>
                </div>
            </div>
            <div id="waivers" class="tab-content">
                <div class="card">
                    <h2 class="card-title">Team Waiver Wire Activity</h2>
                    <p class="card-subtitle">Total adds and points scored while player was on team</p>
                    <div class="ranking-list" id="waiver-activity-list"></div>
                </div>
                <div class="card">
                    <h2 class="card-title">Best Waiver Pickups</h2>
                    <p class="card-subtitle">Top individual waiver pickups by points scored on team</p>
                    <div id="best-pickups-list"></div>
                </div>
            </div>
            <div id="draft" class="tab-content">
                <div class="card">
                    <h2 class="card-title">Top 30 Scorers vs Draft Order</h2>
                    <p class="card-subtitle">Actual performance vs draft position</p>
                    <div class="draft-comparison" id="draft-comparison"></div>
                </div>
                <div class="two-column">
                    <div class="card"><h2 class="card-title">Draft Steals</h2><p class="card-subtitle">Late round picks who delivered big value</p><div id="draft-steals-list"></div></div>
                    <div class="card"><h2 class="card-title">Draft Busts</h2><p class="card-subtitle">Early picks that underperformed</p><div id="draft-busts-list"></div></div>
                </div>
            </div>
            <div id="playoffs" class="tab-content">
                <div class="two-column">
                    <div class="stat-card"><div class="label">Best Playoff Week</div><div class="value" id="best-playoff-week-name">-</div><div class="detail" id="best-playoff-week-detail">-</div></div>
                    <div class="stat-card"><div class="label">Worst Playoff Week</div><div class="value" id="worst-playoff-week-name">-</div><div class="detail" id="worst-playoff-week-detail">-</div></div>
                </div>
                <div class="card"><h2 class="card-title">Team Playoff Performance</h2><p class="card-subtitle">Total points scored during playoff weeks</p><div class="ranking-list" id="playoff-performance-list"></div></div>
                <div class="card"><h2 class="card-title">Playoff Consistency</h2><div class="ranking-list" id="playoff-consistency-list"></div></div>
            </div>
            <div id="awards" class="tab-content"><div class="awards-grid" id="awards-grid"></div></div>
        </div>
        <div id="error" class="error" style="display: none;"><h2>Error Loading Data</h2><p id="error-message"></p></div>
    </div>
    <script>
        const LEAGUE_ID = '1182717772878315520';
        let leagueData = {}, usersData = [], rostersData = [], matchupsData = {}, transactionsData = [];
        let draftsData = [], draftPicksData = [], playersData = {}, playerWeeklyPoints = {};
        let userMap = {}, rosterMap = {}, winnersBracket = [];
        // Track when players were dropped (to calculate points while on team)
        let playerDropWeek = {}; // playerId -> { rosterId -> dropWeek }
        const API_BASE = 'https://api.sleeper.app/v1';

        async function fetchJSON(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to fetch ${url}`);
            return response.json();
        }

        function updateLoadingStatus(status) {
            document.getElementById('loading-status').textContent = status;
        }

        async function init() {
            try {
                updateLoadingStatus('Fetching league info...');
                leagueData = await fetchJSON(`${API_BASE}/league/${LEAGUE_ID}`);
                document.getElementById('league-name').textContent = leagueData.name || 'Fantasy League';

                updateLoadingStatus('Fetching users...');
                usersData = await fetchJSON(`${API_BASE}/league/${LEAGUE_ID}/users`);
                
                updateLoadingStatus('Fetching rosters...');
                rostersData = await fetchJSON(`${API_BASE}/league/${LEAGUE_ID}/rosters`);

                usersData.forEach(user => { userMap[user.user_id] = user; });
                rostersData.forEach(roster => {
                    const user = usersData.find(u => u.user_id === roster.owner_id);
                    rosterMap[roster.roster_id] = {
                        ...roster,
                        username: user?.display_name || user?.username || `Team ${roster.roster_id}`,
                        teamName: user?.metadata?.team_name || user?.display_name || `Team ${roster.roster_id}`
                    };
                });

                updateLoadingStatus('Fetching matchups...');
                const matchupPromises = [];
                for (let week = 1; week <= 17; week++) {
                    matchupPromises.push(
                        fetchJSON(`${API_BASE}/league/${LEAGUE_ID}/matchups/${week}`)
                            .then(data => ({ week, data })).catch(() => ({ week, data: [] }))
                    );
                }
                const matchupResults = await Promise.all(matchupPromises);
                matchupResults.forEach(({ week, data }) => { matchupsData[week] = data; });

                updateLoadingStatus('Processing player scores...');
                for (let week = 1; week <= 17; week++) {
                    const weekMatchups = matchupsData[week] || [];
                    weekMatchups.forEach(matchup => {
                        if (matchup.players_points) {
                            Object.entries(matchup.players_points).forEach(([playerId, points]) => {
                                if (!playerWeeklyPoints[playerId]) playerWeeklyPoints[playerId] = {};
                                playerWeeklyPoints[playerId][week] = points;
                            });
                        }
                    });
                }

                updateLoadingStatus('Fetching transactions...');
                const txPromises = [];
                for (let week = 1; week <= 18; week++) {
                    txPromises.push(fetchJSON(`${API_BASE}/league/${LEAGUE_ID}/transactions/${week}`).then(data => data || []).catch(() => []));
                }
                const txResults = await Promise.all(txPromises);
                transactionsData = txResults.flat();

                // Build player drop tracking
                transactionsData.forEach(tx => {
                    if (tx.status === 'complete' && tx.drops) {
                        const week = tx.leg || 1;
                        Object.entries(tx.drops).forEach(([playerId, rosterId]) => {
                            if (!playerDropWeek[playerId]) playerDropWeek[playerId] = {};
                            playerDropWeek[playerId][rosterId] = week;
                        });
                    }
                });

                updateLoadingStatus('Fetching playoff brackets...');
                try { winnersBracket = await fetchJSON(`${API_BASE}/league/${LEAGUE_ID}/winners_bracket`); } catch (e) { winnersBracket = []; }

                updateLoadingStatus('Fetching draft data...');
                draftsData = await fetchJSON(`${API_BASE}/league/${LEAGUE_ID}/drafts`);
                if (draftsData.length > 0) {
                    draftPicksData = await fetchJSON(`${API_BASE}/draft/${draftsData[0].draft_id}/picks`);
                }

                updateLoadingStatus('Fetching player database...');
                try { playersData = await fetchJSON(`${API_BASE}/players/nfl`); } catch (e) { playersData = {}; }

                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                renderOverview(); renderEfficiency(); renderSchedule(); renderConsistency();
                renderTrades(); renderWaivers(); renderDraft(); renderPlayoffs(); renderAwards();
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error-message').textContent = error.message;
            }
        }

        function getPlayerName(playerId) {
            const player = playersData[playerId];
            if (player) return `${player.first_name} ${player.last_name}`;
            if (playerId && playerId.length <= 3 && playerId === playerId.toUpperCase()) return `${playerId} D/ST`;
            return playerId || 'Unknown';
        }

        function getPlayerInfo(playerId) {
            const player = playersData[playerId];
            if (player) return `${player.position || ''} - ${player.team || 'FA'}`;
            if (playerId && playerId.length <= 3) return 'DEF';
            return '';
        }

        function getPlayerTotalPoints(playerId) {
            const weekPoints = playerWeeklyPoints[playerId];
            if (!weekPoints) return 0;
            return Object.values(weekPoints).reduce((sum, pts) => sum + (pts || 0), 0);
        }

        function getPlayerPointsAfterWeek(playerId, afterWeek) {
            const weekPoints = playerWeeklyPoints[playerId];
            if (!weekPoints) return 0;
            return Object.entries(weekPoints).filter(([week]) => parseInt(week) > afterWeek).reduce((sum, [, pts]) => sum + (pts || 0), 0);
        }

        // Get points for a player only while they were on a specific team
        function getPlayerPointsOnTeam(playerId, rosterId, addWeek) {
            const weekPoints = playerWeeklyPoints[playerId];
            if (!weekPoints) return 0;
            
            // Find when they were dropped from this team (if ever)
            const dropWeek = playerDropWeek[playerId]?.[rosterId] || 18; // 18 means never dropped
            
            return Object.entries(weekPoints)
                .filter(([week]) => {
                    const w = parseInt(week);
                    return w >= addWeek && w < dropWeek;
                })
                .reduce((sum, [, pts]) => sum + (pts || 0), 0);
        }

        function calculateTeamStats() {
            const teamStats = {};
            Object.values(rosterMap).forEach(roster => {
                const fpts = roster.settings?.fpts || 0;
                const fptsDecimal = roster.settings?.fpts_decimal || 0;
                const totalPoints = fpts + (fptsDecimal / 100);
                const fptsAgainst = roster.settings?.fpts_against || 0;
                const fptsAgainstDecimal = roster.settings?.fpts_against_decimal || 0;
                const totalPointsAgainst = fptsAgainst + (fptsAgainstDecimal / 100);
                teamStats[roster.roster_id] = {
                    roster_id: roster.roster_id, username: roster.username, teamName: roster.teamName,
                    totalPoints, wins: roster.settings?.wins || 0, losses: roster.settings?.losses || 0,
                    ties: roster.settings?.ties || 0, pointsAgainst: totalPointsAgainst,
                    weeklyPoints: [], weeklyMaxPoints: []
                };
            });

            for (let week = 1; week <= 17; week++) {
                const weekMatchups = matchupsData[week] || [];
                weekMatchups.forEach(matchup => {
                    if (teamStats[matchup.roster_id]) {
                        const points = matchup.points || 0;
                        teamStats[matchup.roster_id].weeklyPoints.push({ week, points });
                        let maxPossible = points;
                        if (matchup.players_points) {
                            const allPlayerPoints = Object.entries(matchup.players_points).map(([id, pts]) => pts || 0).sort((a, b) => b - a);
                            const rosterPositions = leagueData.roster_positions || [];
                            const starterSlots = rosterPositions.filter(p => p !== 'BN' && p !== 'IR').length || 9;
                            maxPossible = allPlayerPoints.slice(0, starterSlots).reduce((sum, p) => sum + p, 0);
                        }
                        teamStats[matchup.roster_id].weeklyMaxPoints.push({ week, points: maxPossible });
                    }
                });
            }
            return teamStats;
        }

        function getChampion() {
            if (winnersBracket && winnersBracket.length > 0) {
                const finalMatch = winnersBracket.find(m => m.p === 1);
                if (finalMatch && finalMatch.w) return rosterMap[finalMatch.w]?.username || `Team ${finalMatch.w}`;
                const maxRound = Math.max(...winnersBracket.map(m => m.r || 0));
                const champMatch = winnersBracket.find(m => m.r === maxRound);
                if (champMatch && champMatch.w) return rosterMap[champMatch.w]?.username || `Team ${champMatch.w}`;
            }
            const teamStats = calculateTeamStats();
            const bestTeam = Object.values(teamStats).sort((a, b) => b.wins !== a.wins ? b.wins - a.wins : b.totalPoints - a.totalPoints)[0];
            return bestTeam?.username || 'TBD';
        }

        function renderOverview() {
            const teamStats = calculateTeamStats();
            const teams = Object.values(teamStats);
            const topScorer = [...teams].sort((a, b) => b.totalPoints - a.totalPoints)[0];
            
            const teamsWithEfficiency = teams.map(team => {
                const totalActual = team.weeklyPoints.reduce((sum, w) => sum + w.points, 0);
                const totalMax = team.weeklyMaxPoints.reduce((sum, w) => sum + w.points, 0);
                return { ...team, efficiency: totalMax > 0 ? (totalActual / totalMax * 100) : 0 };
            });
            const bestEfficiency = [...teamsWithEfficiency].sort((a, b) => b.efficiency - a.efficiency)[0];

            const teamsWithExpected = teams.map(team => {
                let expectedWins = 0;
                team.weeklyPoints.forEach(wp => {
                    const otherTeamsPoints = teams.filter(t => t.roster_id !== team.roster_id)
                        .map(t => t.weeklyPoints.find(w => w.week === wp.week)?.points || 0);
                    if (otherTeamsPoints.length > 0) expectedWins += otherTeamsPoints.filter(p => wp.points > p).length / otherTeamsPoints.length;
                });
                return { ...team, expectedWins, luck: team.wins - expectedWins };
            });
            const luckiest = [...teamsWithExpected].sort((a, b) => b.luck - a.luck)[0];
            const champion = getChampion();

            let biggestBlowout = { margin: 0 }, closestMatchup = { margin: Infinity };
            for (let week = 1; week <= 17; week++) {
                const weekMatchups = matchupsData[week] || [];
                const matchupGroups = {};
                weekMatchups.forEach(m => { if (m.matchup_id) { if (!matchupGroups[m.matchup_id]) matchupGroups[m.matchup_id] = []; matchupGroups[m.matchup_id].push(m); }});
                Object.values(matchupGroups).forEach(group => {
                    if (group.length === 2) {
                        const margin = Math.abs((group[0].points || 0) - (group[1].points || 0));
                        const winner = group[0].points > group[1].points ? group[0] : group[1];
                        const loser = group[0].points > group[1].points ? group[1] : group[0];
                        if (margin > biggestBlowout.margin) biggestBlowout = { margin, week, winner: rosterMap[winner.roster_id]?.username, loser: rosterMap[loser.roster_id]?.username, winnerPoints: winner.points || 0, loserPoints: loser.points || 0 };
                        if (margin < closestMatchup.margin && margin > 0) closestMatchup = { margin, week, winner: rosterMap[winner.roster_id]?.username, loser: rosterMap[loser.roster_id]?.username, winnerPoints: winner.points || 0, loserPoints: loser.points || 0 };
                    }
                });
            }

            document.getElementById('overview-stats').innerHTML = `
                <div class="stat-card champion"><div class="label">üèÜ League Champion</div><div class="value">${champion}</div><div class="detail">2025 Season Winner</div></div>
                <div class="stat-card"><div class="label">Top Scorer</div><div class="value">${topScorer?.username || '-'}</div><div class="detail highlight">${topScorer?.totalPoints?.toFixed(2) || 0} pts</div></div>
                <div class="stat-card"><div class="label">Best Manager</div><div class="value">${bestEfficiency?.username || '-'}</div><div class="detail">${bestEfficiency?.efficiency?.toFixed(1) || 0}% efficiency</div></div>
                <div class="stat-card"><div class="label">Luckiest</div><div class="value">${luckiest?.username || '-'}</div><div class="detail highlight">+${luckiest?.luck?.toFixed(1) || 0} wins</div></div>`;

            document.getElementById('biggest-blowout').innerHTML = biggestBlowout.margin > 0 ? `
                <div style="padding: 10px 0;"><div style="font-weight: 600; color: var(--success); font-size: 1.2rem;">${biggestBlowout.winner}</div>
                <div style="color: var(--text-secondary); margin: 5px 0;">vs ${biggestBlowout.loser}</div><div style="color: var(--text-secondary);">Week ${biggestBlowout.week}</div>
                <div class="matchup-score"><span class="winner-score">${biggestBlowout.winnerPoints.toFixed(2)}</span><span style="color: var(--text-secondary);"> - </span><span class="loser-score">${biggestBlowout.loserPoints.toFixed(2)}</span></div>
                <div style="color: var(--success); font-family: 'Orbitron', sans-serif; font-size: 1.3rem; margin-top: 10px;">${biggestBlowout.margin.toFixed(1)} pt margin</div></div>` : '<p>No data</p>';

            document.getElementById('closest-matchup').innerHTML = closestMatchup.margin < Infinity ? `
                <div style="padding: 10px 0;"><div style="font-weight: 600; color: var(--accent-cyan); font-size: 1.2rem;">${closestMatchup.winner}</div>
                <div style="color: var(--text-secondary); margin: 5px 0;">vs ${closestMatchup.loser}</div><div style="color: var(--text-secondary);">Week ${closestMatchup.week}</div>
                <div class="matchup-score"><span class="winner-score">${closestMatchup.winnerPoints.toFixed(2)}</span><span style="color: var(--text-secondary);"> - </span><span class="loser-score">${closestMatchup.loserPoints.toFixed(2)}</span></div>
                <div style="color: var(--warning); font-family: 'Orbitron', sans-serif; font-size: 1.3rem; margin-top: 10px;">${closestMatchup.margin.toFixed(2)} pt margin</div></div>` : '<p>No data</p>';
        }

        function renderEfficiency() {
            const teamStats = calculateTeamStats();
            const teamsWithEfficiency = Object.values(teamStats).map(team => {
                const totalActual = team.weeklyPoints.reduce((sum, w) => sum + w.points, 0);
                const totalMax = team.weeklyMaxPoints.reduce((sum, w) => sum + w.points, 0);
                const efficiency = totalMax > 0 ? (totalActual / totalMax * 100) : 0;
                return { ...team, efficiency, pointsLeftOnBench: totalMax - totalActual };
            }).sort((a, b) => b.efficiency - a.efficiency);

            let html = '';
            teamsWithEfficiency.forEach((team, idx) => {
                const rankClass = idx === 0 ? 'gold' : idx === 1 ? 'silver' : idx === 2 ? 'bronze' : '';
                html += `<div class="ranking-item"><span class="rank ${rankClass}">#${idx + 1}</span><span class="name">${team.username}</span>
                    <div class="progress-container"><div class="progress-bar"><div class="progress-fill" style="width: ${Math.min(team.efficiency, 100)}%"></div></div>
                    <div class="progress-label">Points left on bench: ${team.pointsLeftOnBench.toFixed(1)}</div></div>
                    <span class="stat neutral">${team.efficiency.toFixed(1)}%</span></div>`;
            });
            document.getElementById('efficiency-list').innerHTML = html || '<p>No data</p>';
        }

        function renderSchedule() {
            const teamStats = calculateTeamStats();
            const teams = Object.values(teamStats);
            const teamsWithLuck = teams.map(team => {
                let expectedWins = 0;
                team.weeklyPoints.forEach(wp => {
                    const otherTeamsPoints = teams.filter(t => t.roster_id !== team.roster_id).map(t => t.weeklyPoints.find(w => w.week === wp.week)?.points || 0);
                    if (otherTeamsPoints.length > 0) expectedWins += otherTeamsPoints.filter(p => wp.points > p).length / otherTeamsPoints.length;
                });
                return { ...team, expectedWins, luck: team.wins - expectedWins };
            }).sort((a, b) => b.luck - a.luck);

            let luckHtml = '';
            teamsWithLuck.forEach((team, idx) => {
                const luckClass = team.luck >= 0 ? 'positive' : 'negative';
                const sign = team.luck >= 0 ? '+' : '';
                const arrow = team.luck >= 0 ? 'üìà' : 'üìâ';
                luckHtml += `<div class="ranking-item"><span class="rank">#${idx + 1}</span><span class="name">${team.username}</span>
                    <span class="sub-stat">Actual: <strong>${team.wins}W</strong></span><span class="sub-stat">Expected: <strong>${team.expectedWins.toFixed(1)}W</strong></span>
                    <span class="stat ${luckClass}">${arrow} ${sign}${team.luck.toFixed(1)}</span></div>`;
            });
            document.getElementById('schedule-luck-list').innerHTML = luckHtml || '<p>No data</p>';

            const teamsWithSOS = teams.map(team => ({ ...team, avgAgainst: team.weeklyPoints.length > 0 ? team.pointsAgainst / team.weeklyPoints.length : 0 })).sort((a, b) => b.avgAgainst - a.avgAgainst);
            let sosHtml = '';
            teamsWithSOS.forEach((team, idx) => {
                sosHtml += `<div class="ranking-item"><span class="rank">#${idx + 1}</span><span class="name">${team.username}</span><span class="stat neutral">${team.avgAgainst.toFixed(1)}</span><span class="sub-stat">avg pts against/week</span></div>`;
            });
            document.getElementById('sos-list').innerHTML = sosHtml || '<p>No data</p>';
        }

        function renderConsistency() {
            const teams = Object.values(calculateTeamStats()).map(team => {
                const points = team.weeklyPoints.map(w => w.points);
                if (points.length === 0) return { ...team, avg: 0, stdDev: 0, consistency: 0, high: 0, low: 0 };
                const avg = points.reduce((a, b) => a + b, 0) / points.length;
                const variance = points.reduce((sum, p) => sum + Math.pow(p - avg, 2), 0) / points.length;
                const stdDev = Math.sqrt(variance);
                return { ...team, avg, stdDev, consistency: avg > 0 ? 100 - (stdDev / avg * 100) : 0, high: Math.max(...points), low: Math.min(...points) };
            }).sort((a, b) => b.consistency - a.consistency);

            let html = '';
            teams.forEach((team, idx) => {
                html += `<div class="ranking-item"><span class="rank">#${idx + 1}</span><span class="name">${team.username}</span>
                    <span class="sub-stat">Avg: <strong>${team.avg.toFixed(1)}</strong></span><span class="sub-stat">Std Dev: <strong>${team.stdDev.toFixed(1)}</strong></span>
                    <span class="sub-stat">High: <span style="color: var(--success)">${team.high.toFixed(1)}</span></span><span class="sub-stat">Low: <span style="color: var(--danger)">${team.low.toFixed(1)}</span></span>
                    <span class="stat neutral">${team.consistency.toFixed(1)}</span></div>`;
            });
            document.getElementById('consistency-list').innerHTML = html || '<p>No data</p>';
        }

        function renderTrades() {
            const trades = transactionsData.filter(tx => tx.type === 'trade' && tx.status === 'complete');
            const teamTradeValue = {};
            Object.values(rosterMap).forEach(roster => { teamTradeValue[roster.roster_id] = { username: roster.username, trades: 0, netValue: 0 }; });

            trades.forEach(trade => {
                const week = trade.leg || 1;
                const adds = trade.adds || {}, drops = trade.drops || {};
                trade.roster_ids?.forEach(rid => { if (teamTradeValue[rid]) teamTradeValue[rid].trades++; });
                Object.entries(adds).forEach(([playerId, rosterId]) => {
                    if (teamTradeValue[rosterId]) teamTradeValue[rosterId].netValue += getPlayerPointsAfterWeek(playerId, week);
                });
                Object.entries(drops).forEach(([playerId, rosterId]) => {
                    if (teamTradeValue[rosterId]) teamTradeValue[rosterId].netValue -= getPlayerPointsAfterWeek(playerId, week);
                });
            });

            const sortedPerformance = Object.values(teamTradeValue).filter(t => t.trades > 0).sort((a, b) => b.netValue - a.netValue);
            let perfHtml = '';
            sortedPerformance.forEach((team, idx) => {
                const valueClass = team.netValue >= 0 ? 'positive' : 'negative';
                const sign = team.netValue >= 0 ? '+' : '';
                perfHtml += `<div class="ranking-item"><span class="rank">#${idx + 1}</span><span class="name">${team.username}</span>
                    <span class="sub-stat">${team.trades} trade${team.trades !== 1 ? 's' : ''}</span><span class="stat ${valueClass}">${sign}${team.netValue.toFixed(1)} pts</span></div>`;
            });
            document.getElementById('trade-performance-list').innerHTML = perfHtml || '<p>No trades this season</p>';

            let tradesHtml = '';
            trades.slice(0, 30).forEach(trade => {
                const week = trade.leg || 1;
                const adds = trade.adds || {}, drops = trade.drops || {};
                const rosterAdds = {}, rosterDrops = {};
                Object.entries(adds).forEach(([playerId, rosterId]) => {
                    if (!rosterAdds[rosterId]) rosterAdds[rosterId] = [];
                    rosterAdds[rosterId].push({ name: getPlayerName(playerId), pts: getPlayerPointsAfterWeek(playerId, week) });
                });
                Object.entries(drops).forEach(([playerId, rosterId]) => {
                    if (!rosterDrops[rosterId]) rosterDrops[rosterId] = [];
                    rosterDrops[rosterId].push({ name: getPlayerName(playerId), pts: getPlayerPointsAfterWeek(playerId, week) });
                });
                const involvedRosters = [...new Set([...Object.keys(rosterAdds), ...Object.keys(rosterDrops)])];
                involvedRosters.forEach(rosterId => {
                    const teamName = rosterMap[rosterId]?.username || `Team ${rosterId}`;
                    const got = rosterAdds[rosterId] || [], gave = rosterDrops[rosterId] || [];
                    const netValue = got.reduce((sum, p) => sum + p.pts, 0) - gave.reduce((sum, p) => sum + p.pts, 0);
                    const valueClass = netValue >= 0 ? 'positive' : 'negative';
                    const sign = netValue >= 0 ? '+' : '';
                    tradesHtml += `<div class="trade-item"><div class="trade-header"><span class="trade-team">${teamName}</span><span style="color: var(--text-secondary);">Week ${week}</span>
                        <span class="trade-value ${valueClass}">${sign}${netValue.toFixed(1)} pts</span></div>
                        <div class="trade-players"><div class="trade-got">+ ${got.map(p => `${p.name} <span>(${p.pts.toFixed(1)})</span>`).join(', ') || 'None'}</div>
                        <div class="trade-gave">- ${gave.map(p => `${p.name} <span>(${p.pts.toFixed(1)})</span>`).join(', ') || 'None'}</div></div></div>`;
                });
            });
            document.getElementById('all-trades-list').innerHTML = tradesHtml || '<p>No trades this season</p>';
        }

        function renderWaivers() {
            const waiverTxs = transactionsData.filter(tx => (tx.type === 'waiver' || tx.type === 'free_agent') && tx.status === 'complete');
            const waiverPickups = [], waiverActivity = {};
            Object.values(rosterMap).forEach(roster => { waiverActivity[roster.roster_id] = { username: roster.username, adds: 0, totalPoints: 0 }; });

            waiverTxs.forEach(tx => {
                const week = tx.leg || 1;
                Object.entries(tx.adds || {}).forEach(([playerId, rosterId]) => {
                    if (waiverActivity[rosterId]) {
                        // Only count points while player was on this team
                        const pointsScored = getPlayerPointsOnTeam(playerId, rosterId, week);
                        waiverActivity[rosterId].adds++;
                        waiverActivity[rosterId].totalPoints += pointsScored;
                        waiverPickups.push({ 
                            playerId, 
                            name: getPlayerName(playerId), 
                            info: getPlayerInfo(playerId), 
                            rosterId, 
                            username: rosterMap[rosterId]?.username, 
                            week, 
                            points: pointsScored 
                        });
                    }
                });
            });

            const sortedActivity = Object.values(waiverActivity).sort((a, b) => b.totalPoints - a.totalPoints);
            let activityHtml = '';
            sortedActivity.forEach((team, idx) => {
                const avgPerAdd = team.adds > 0 ? team.totalPoints / team.adds : 0;
                activityHtml += `<div class="ranking-item"><span class="rank">#${idx + 1}</span><span class="name">${team.username}</span>
                    <span class="sub-stat">Total Adds: <strong>${team.adds}</strong></span><span class="sub-stat">Avg Per Add: <strong style="color: var(--accent-cyan)">${avgPerAdd.toFixed(1)} pts</strong></span>
                    <span class="stat neutral">${team.totalPoints.toFixed(1)} pts</span></div>`;
            });
            document.getElementById('waiver-activity-list').innerHTML = activityHtml || '<p>No waiver activity</p>';

            const bestPickups = waiverPickups.sort((a, b) => b.points - a.points).slice(0, 15);
            let pickupsHtml = '';
            bestPickups.forEach((pickup, idx) => {
                pickupsHtml += `<div class="waiver-item"><span class="waiver-rank">#${idx + 1}</span><div class="waiver-player">
                    <div class="name">${pickup.name} (${pickup.info})</div><div class="info">${pickup.username} ‚Ä¢ Week ${pickup.week}</div></div>
                    <span class="waiver-points">${pickup.points.toFixed(1)}</span></div>`;
            });
            document.getElementById('best-pickups-list').innerHTML = pickupsHtml || '<p>No waiver pickups found</p>';
        }

        function renderDraft() {
            if (draftPicksData.length === 0) {
                document.getElementById('draft-comparison').innerHTML = '<p>No draft data available</p>';
                document.getElementById('draft-steals-list').innerHTML = '<p>No draft data</p>';
                document.getElementById('draft-busts-list').innerHTML = '<p>No draft data</p>';
                return;
            }

            const draftedPlayersWithPoints = draftPicksData.map(pick => ({
                ...pick,
                playerName: pick.metadata?.first_name && pick.metadata?.last_name ? `${pick.metadata.first_name} ${pick.metadata.last_name}` : getPlayerName(pick.player_id),
                position: pick.metadata?.position || '', team: pick.metadata?.team || '',
                drafter: rosterMap[pick.roster_id]?.username || `Team ${pick.roster_id}`,
                totalPoints: getPlayerTotalPoints(pick.player_id)
            }));

            const top30Scorers = [...draftedPlayersWithPoints].sort((a, b) => b.totalPoints - a.totalPoints).slice(0, 30);
            const first30Picks = [...draftedPlayersWithPoints].sort((a, b) => a.pick_no - b.pick_no).slice(0, 30);

            let actualHtml = '<div class="draft-column actual"><h3>Actual Top 30 Scorers</h3>';
            top30Scorers.forEach((player, idx) => {
                actualHtml += `<div class="draft-pick"><span class="pick-num">#${idx + 1}</span><span class="player-name">${player.playerName} (${player.position} - ${player.team})</span>
                    <span class="points success">${player.totalPoints.toFixed(1)} pts</span><span class="drafter">(Pick ${player.pick_no})</span></div>`;
            });
            actualHtml += '</div>';

            let draftedHtml = '<div class="draft-column drafted"><h3>Draft Order (First 30)</h3>';
            first30Picks.forEach(pick => {
                const actualRank = top30Scorers.findIndex(p => p.player_id === pick.player_id) + 1;
                const isHit = actualRank > 0 && actualRank <= 30;
                const colorClass = isHit ? 'success' : '';
                const checkMark = isHit ? ' ‚úì' : '';
                draftedHtml += `<div class="draft-pick"><span class="pick-num">#${pick.pick_no}</span><span class="player-name ${colorClass}">${pick.playerName} (${pick.position} - ${pick.team})${checkMark}</span>
                    <span class="points ${colorClass}">${pick.totalPoints.toFixed(1)} pts</span><span class="drafter">${pick.drafter}</span></div>`;
            });
            draftedHtml += '</div>';
            document.getElementById('draft-comparison').innerHTML = actualHtml + draftedHtml;

            // Hardcoded draft steals as requested
            const stealNames = ['Skattebo', 'J Higgins', 'Dart', 'Tuten', 'M Taylor', 'Ferguson'];
            const manualSteals = draftedPlayersWithPoints.filter(p => {
                const name = p.playerName.toLowerCase();
                return stealNames.some(s => name.includes(s.toLowerCase()));
            }).sort((a, b) => b.totalPoints - a.totalPoints);

            let stealsHtml = '';
            if (manualSteals.length > 0) {
                manualSteals.forEach((player, idx) => {
                    stealsHtml += `<div class="draft-pick"><span class="pick-num">#${idx + 1}</span><span class="player-name success">${player.playerName} (${player.position} - ${player.team})</span>
                        <span class="points success">${player.totalPoints.toFixed(1)}</span><span class="drafter">${player.drafter} ‚Ä¢ Pick ${player.pick_no}</span></div>`;
                });
            } else {
                // Fallback if names not found
                const draftSteals = draftedPlayersWithPoints.filter(p => p.pick_no > 60 && p.totalPoints > 50).sort((a, b) => b.totalPoints - a.totalPoints).slice(0, 10);
                draftSteals.forEach((player, idx) => {
                    stealsHtml += `<div class="draft-pick"><span class="pick-num">#${idx + 1}</span><span class="player-name success">${player.playerName} (${player.position} - ${player.team})</span>
                        <span class="points success">${player.totalPoints.toFixed(1)}</span><span class="drafter">${player.drafter} ‚Ä¢ Pick ${player.pick_no}</span></div>`;
                });
            }
            document.getElementById('draft-steals-list').innerHTML = stealsHtml || '<p>No significant steals</p>';

            const avgPointsTop30 = top30Scorers.reduce((sum, p) => sum + p.totalPoints, 0) / 30;
            const draftBusts = draftedPlayersWithPoints.filter(p => p.pick_no <= 40 && p.totalPoints < avgPointsTop30 * 0.5).sort((a, b) => a.totalPoints - b.totalPoints).slice(0, 10);
            let bustsHtml = '';
            draftBusts.forEach((player, idx) => {
                bustsHtml += `<div class="draft-pick"><span class="pick-num">#${idx + 1}</span><span class="player-name danger">${player.playerName} (${player.position} - ${player.team})</span>
                    <span class="points danger">${player.totalPoints.toFixed(1)}</span><span class="drafter">${player.drafter} ‚Ä¢ Pick ${player.pick_no}</span></div>`;
            });
            document.getElementById('draft-busts-list').innerHTML = bustsHtml || '<p>No significant busts</p>';
        }

        function renderPlayoffs() {
            const playoffWeeks = [15, 16, 17];
            const teams = Object.values(calculateTeamStats());
            const playoffPerformance = teams.map(team => {
                const playoffPoints = team.weeklyPoints.filter(w => playoffWeeks.includes(w.week)).map(w => w.points);
                const total = playoffPoints.reduce((a, b) => a + b, 0);
                const avg = playoffPoints.length > 0 ? total / playoffPoints.length : 0;
                const seasonAvg = team.weeklyPoints.length > 0 ? team.weeklyPoints.reduce((a, b) => a + b.points, 0) / team.weeklyPoints.length : 0;
                return { ...team, playoffTotal: total, playoffAvg: avg, seasonAvg, diff: avg - seasonAvg, weeksPlayed: playoffPoints.length };
            }).sort((a, b) => b.playoffTotal - a.playoffTotal);

            let bestWeek = { points: 0 }, worstWeek = { points: Infinity };
            playoffWeeks.forEach(week => {
                (matchupsData[week] || []).forEach(m => {
                    const points = m.points || 0, team = rosterMap[m.roster_id]?.username || `Team ${m.roster_id}`;
                    if (points > bestWeek.points) bestWeek = { points, team, week };
                    if (points < worstWeek.points && points > 0) worstWeek = { points, team, week };
                });
            });

            document.getElementById('best-playoff-week-name').textContent = bestWeek.team || '-';
            document.getElementById('best-playoff-week-detail').innerHTML = bestWeek.points > 0 ? `Week ${bestWeek.week}<br><span style="color: var(--success)">${bestWeek.points.toFixed(1)} pts</span>` : '-';
            document.getElementById('worst-playoff-week-name').textContent = worstWeek.team || '-';
            document.getElementById('worst-playoff-week-detail').innerHTML = worstWeek.points < Infinity ? `Week ${worstWeek.week}<br><span style="color: var(--danger)">${worstWeek.points.toFixed(1)} pts</span>` : '-';

            let perfHtml = '';
            playoffPerformance.forEach((team, idx) => {
                const diffClass = team.diff >= 0 ? 'positive' : 'negative';
                const sign = team.diff >= 0 ? '+' : '';
                const arrow = team.diff >= 0 ? 'üìà' : 'üìâ';
                perfHtml += `<div class="ranking-item"><span class="rank">#${idx + 1}</span><span class="name">${team.username}</span>
                    <span class="sub-stat">${team.weeksPlayed} weeks</span><span class="sub-stat">Playoff Avg: <strong>${team.playoffAvg.toFixed(1)}</strong></span>
                    <span class="sub-stat">Season Avg: <strong>${team.seasonAvg.toFixed(1)}</strong></span><span class="sub-stat ${diffClass}">${arrow} ${sign}${team.diff.toFixed(1)}</span>
                    <span class="stat neutral">${team.playoffTotal.toFixed(1)} pts</span></div>`;
            });
            document.getElementById('playoff-performance-list').innerHTML = perfHtml || '<p>No playoff data</p>';

            const playoffConsistency = teams.map(team => {
                const playoffPoints = team.weeklyPoints.filter(w => playoffWeeks.includes(w.week)).map(w => w.points);
                if (playoffPoints.length === 0) return { ...team, avg: 0, stdDev: 0, consistency: 0 };
                const avg = playoffPoints.reduce((a, b) => a + b, 0) / playoffPoints.length;
                const variance = playoffPoints.reduce((sum, p) => sum + Math.pow(p - avg, 2), 0) / playoffPoints.length;
                const stdDev = Math.sqrt(variance);
                return { ...team, avg, stdDev, consistency: avg > 0 ? 100 - (stdDev / avg * 100) : 0 };
            }).sort((a, b) => b.consistency - a.consistency);

            let consHtml = '';
            playoffConsistency.forEach((team, idx) => {
                consHtml += `<div class="ranking-item"><span class="rank">#${idx + 1}</span><span class="name">${team.username}</span>
                    <span class="sub-stat">Avg: <strong>${team.avg.toFixed(1)}</strong></span><span class="sub-stat">Std Dev: <strong>${team.stdDev.toFixed(1)}</strong></span>
                    <span class="stat neutral">${team.consistency.toFixed(1)}</span></div>`;
            });
            document.getElementById('playoff-consistency-list').innerHTML = consHtml || '<p>No playoff data</p>';
        }

        function renderAwards() {
            const teams = Object.values(calculateTeamStats());
            const topScorer = [...teams].sort((a, b) => b.totalPoints - a.totalPoints)[0];
            
            const mostConsistent = [...teams].map(team => {
                const points = team.weeklyPoints.map(w => w.points);
                if (points.length === 0) return { ...team, consistency: 0 };
                const avg = points.reduce((a, b) => a + b, 0) / points.length;
                const variance = points.reduce((sum, p) => sum + Math.pow(p - avg, 2), 0) / points.length;
                return { ...team, consistency: avg > 0 ? 100 - (Math.sqrt(variance) / avg * 100) : 0 };
            }).sort((a, b) => b.consistency - a.consistency)[0];

            const boomBust = [...teams].map(team => {
                const points = team.weeklyPoints.map(w => w.points);
                if (points.length === 0) return { ...team, volatility: 0 };
                const avg = points.reduce((a, b) => a + b, 0) / points.length;
                const variance = points.reduce((sum, p) => sum + Math.pow(p - avg, 2), 0) / points.length;
                return { ...team, volatility: Math.sqrt(variance) };
            }).sort((a, b) => b.volatility - a.volatility)[0];

            const weeklyWins = {};
            teams.forEach(t => weeklyWins[t.roster_id] = 0);
            for (let week = 1; week <= 17; week++) {
                const weekMatchups = matchupsData[week] || [];
                if (weekMatchups.length > 0) {
                    const topWeekly = weekMatchups.map(m => ({ roster_id: m.roster_id, points: m.points || 0 })).sort((a, b) => b.points - a.points)[0];
                    if (topWeekly && weeklyWins[topWeekly.roster_id] !== undefined) weeklyWins[topWeekly.roster_id]++;
                }
            }
            const mostWeeklyWins = Object.entries(weeklyWins).map(([rid, wins]) => ({ roster_id: parseInt(rid), wins, username: rosterMap[rid]?.username })).sort((a, b) => b.wins - a.wins)[0];

            let lowestWin = { points: Infinity };
            for (let week = 1; week <= 17; week++) {
                const matchupGroups = {};
                (matchupsData[week] || []).forEach(m => { if (m.matchup_id) { if (!matchupGroups[m.matchup_id]) matchupGroups[m.matchup_id] = []; matchupGroups[m.matchup_id].push(m); }});
                Object.values(matchupGroups).forEach(group => {
                    if (group.length === 2) {
                        const winner = group[0].points > group[1].points ? group[0] : group[1];
                        if (winner.points < lowestWin.points && winner.points > 0) lowestWin = { points: winner.points, team: rosterMap[winner.roster_id]?.username, week };
                    }
                });
            }

            const closeWins = {};
            teams.forEach(t => closeWins[t.roster_id] = 0);
            for (let week = 1; week <= 17; week++) {
                const matchupGroups = {};
                (matchupsData[week] || []).forEach(m => { if (m.matchup_id) { if (!matchupGroups[m.matchup_id]) matchupGroups[m.matchup_id] = []; matchupGroups[m.matchup_id].push(m); }});
                Object.values(matchupGroups).forEach(group => {
                    if (group.length === 2) {
                        const margin = Math.abs((group[0].points || 0) - (group[1].points || 0));
                        const winner = group[0].points > group[1].points ? group[0] : group[1];
                        if (margin < 5 && closeWins[winner.roster_id] !== undefined) closeWins[winner.roster_id]++;
                    }
                });
            }
            const mostCloseWins = Object.entries(closeWins).map(([rid, wins]) => ({ roster_id: parseInt(rid), wins, username: rosterMap[rid]?.username })).sort((a, b) => b.wins - a.wins)[0];

            const bestEfficiency = [...teams].map(team => {
                const totalActual = team.weeklyPoints.reduce((sum, w) => sum + w.points, 0);
                const totalMax = team.weeklyMaxPoints.reduce((sum, w) => sum + w.points, 0);
                return { ...team, efficiency: totalMax > 0 ? (totalActual / totalMax * 100) : 0 };
            }).sort((a, b) => b.efficiency - a.efficiency)[0];

            const worstEfficiency = [...teams].map(team => {
                const totalActual = team.weeklyPoints.reduce((sum, w) => sum + w.points, 0);
                const totalMax = team.weeklyMaxPoints.reduce((sum, w) => sum + w.points, 0);
                return { ...team, efficiency: totalMax > 0 ? (totalActual / totalMax * 100) : 0 };
            }).sort((a, b) => a.efficiency - b.efficiency)[0];

            const champion = getChampion();

            const awards = [
                { title: 'üèÜ League Champion', winner: champion, detail: '2025 Season Winner' },
                { title: 'Top Scorer', winner: topScorer?.username || '-', detail: `${topScorer?.totalPoints?.toFixed(1) || 0} total points` },
                { title: 'Best Manager', winner: bestEfficiency?.username || '-', detail: `${bestEfficiency?.efficiency?.toFixed(1) || 0}% lineup efficiency` },
                { title: 'Consistency King', winner: mostConsistent?.username || '-', detail: 'Most predictable scores' },
                { title: 'Boom/Bust King', winner: boomBust?.username || '-', detail: 'Most volatile scores' },
                { title: 'Dominance', winner: mostWeeklyWins?.username || '-', detail: `${mostWeeklyWins?.wins || 0} weekly #1 finishes` },
                { title: 'Cardiac Kid', winner: mostCloseWins?.username || '-', detail: `${mostCloseWins?.wins || 0} close wins (<5 pts)` },
                { title: 'Point Miser', winner: lowestWin.team || '-', detail: lowestWin.points < Infinity ? `${lowestWin.points.toFixed(1)} pts - Lowest winning score` : '-' },
                { title: 'League Taco', winner: worstEfficiency?.username || '-', detail: `${worstEfficiency?.efficiency?.toFixed(1) || 0}% - Worst lineup efficiency` },
                { title: 'Best Record', winner: [...teams].sort((a, b) => b.wins - a.wins)[0]?.username || '-', detail: `${[...teams].sort((a, b) => b.wins - a.wins)[0]?.wins || 0}-${[...teams].sort((a, b) => b.wins - a.wins)[0]?.losses || 0}` }
            ];

            let awardsHtml = '';
            awards.forEach(award => {
                const isChamp = award.title.includes('Champion');
                awardsHtml += `<div class="award-card" ${isChamp ? 'style="border-color: gold; background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);"' : ''}>
                    <div class="award-title">${award.title}</div><div class="winner" ${isChamp ? 'style="color: gold;"' : ''}>${award.winner}</div><div class="detail">${award.detail}</div></div>`;
            });
            document.getElementById('awards-grid').innerHTML = awardsHtml;
        }

        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
            });
        });

        init();
    </script>
</body>
</html>
